---
title: "QAQC MetaData"
author: "Alexandra Lalor"
output:
  html_document:
    theme: readable
    highlight: 
    toc: yes
    toc_depth: 1
    toc_float:
      smooth_scroll: yes
    code_download: true
  pdf_document:
    toc: yes
    toc_depth: '3'
---

# Before Starting

This code is intended to quality check species metadata, including the Local Species Report. This report can be downloaded via the Species menu on the Species Management tab on the FFI Remote App Server.

### Setup {.hidden}

```{r setup, include=FALSE}
## Markdown Options
knitr::opts_chunk$set(echo = FALSE, error = FALSE, warning = FALSE, message = FALSE)
```

```{r install packages, include=FALSE}
## Install packages (if needed)

# install.packages("tidyverse")
# install.packages("Rtools")
# install.packages("janitor")
# install.packages("condformat")
# install.packages("knitr")
# install.packages("here")
```

```{r load packages, include=FALSE}
## Load Packages

# tidyverse and dplyr have lots of useful functions for data cleaning
library(tidyverse)
library(dplyr)
#library(plyr)
# janitor has functions to find duplicates
library(janitor)
# writexl is used to create excel output files
library(writexl)
# condformat is used to format excel output files
library(condformat)
# knitr is used to create output files from R Markdown
library(knitr)
# "here" helps you easily find and reference your working directory
library(here)
```

### Create Function {.hidden}

```{r}
# Create blank data frame as error log template
errors_blank <- data.frame("SavedQuery" = "", "Error" = "", "Fixed" = "", "Explanation" = "", "Queryers" = "")

# Create error group. Duplicate errors will be grouped by these columns.
errors_group <- c("SavedQuery", "Error")

############################################################################################
## Source Code
#Pull in source code that creates QAQC functions and builds an empty error table.
#source("C:/Users/allie/OneDrive/Desktop/R Projects/NER/scripts/1_QAQC/qaqc_function.R")


# QAQC function
qaqc <- function(data, query, query_message, values_check) {

  # Check if there is data to QAQC
  if(nrow(data) == 0) {
  # If there is no data, default to "No Error" data frame
  errors <- errors_blank %>%
    mutate("SavedQuery" = query,
           "Error" = "No Error")
  # If there is data, perform error check
} else {

  # Use relevant dataset to look for errors
  errors <- data %>%
    # Add columns relevant to error checking
           # Populate the "SavedQuery" column with the query name
    mutate("SavedQuery" = query,
           # Populate the "Error" column with the query message and relevant data
           "Error" = paste(query_message, "=", values_data),
           # Create a blank "Fixed" column
           "Fixed" = "",
           # Create a blank "Explanation" column
           "Explanation" = "",
           # Create a blank "Queryers" column
           "Queryers" = "") %>%
    # Filter for data which is "false" (data does not match valid conditions)
    # NA values are treated as "false" (missing data is not valid)
    filter(!(values_check %>% replace_na(FALSE))) %>%
    # Select relevant columns to view errors
    select(colnames(errors_blank))

  # Next, check if there are duplicate errors
  errors_temp <- errors %>%
    get_dupes(errors_group)
  # Merge duplicate errors
  errors <- unique(merge(errors, errors_temp, all = T))
  # If duplicate errors exist, add number of duplicates to error message
  errors <- errors %>%
    mutate(Error = ifelse(is.na(dupe_count), Error, paste0("(x", dupe_count, ") ", Error))) %>%
    select(!"dupe_count")
}

  # Check if there are no errors
  if (nrow(errors) == 0) {
    # If there are no errors, default to "No Error" data frame
    errors <- errors_blank %>%
      mutate(SavedQuery = query,
             Error = "No Error")
    # If there are errors, keep error log you just created
  } else {
    errors <- errors
  }
}
```

### Target Park {.hidden}

```{r}
# designate target park(s)
target_park <- "SHEN"
```

### Adjust File Paths {.hidden}

```{r import data, include=FALSE}
# adjust file paths
#path_main <- "E:/Allie/FireFX_NER/FFI Data Management/"
path_main <- "C:/Users/alalor/OneDrive - DOI/NER/FireFX/FFI Data Management/"
path_data <- paste0(path_main, "Exports/", target_park, "/", target_park, "_")
path_errors <- paste0(path_main, "QAQC/", target_park, "/")
path_errors_name <- paste0(target_park, " Species QAQC Errors")
```

### Load Data {.hidden}

```{r load data, include=FALSE}
## Load Data
SpeciesReport <- read.csv(paste0(path_data, "LocalSpeciesReport.csv"), na.strings = c("","NA","N/A"))
```

### Clean Data {.hidden}

```{r}
# SpeciesReport <- SpeciesReport %>%
#   # remove trailing/leading whitespace
#   mutate(across(where(is.character), str_trim))
# 
# # replace commas with semicolons
# SpeciesReport[] <- lapply(SpeciesReport, function(x) gsub(",", ";", x))
```

### Define Codes {.hidden}

```{r}
# substrate <- c("BARE", "BOLE", "DUFF", "HAY", "LICHEN", "LITT", "LITTER", "MOSS", "ROCK", "ROOT", "SOIL", "WATER", "WOOD", "DDTREE")
# 
# unknown <- c("ASTER", "FERN", "FUNGI", "GRASS", "UNKSPP", "UNKSNAG", "UNK_002", "2FERN", "2FORBD", "2FORBM", "2GRAM", "2PLANT", "2SHRUBD", "2TREE", "2VINEHERB", "2VINEWOOD")
```

# Park: [`r target_park`]{style="color:red"}

# Species Report

[Problem:]{.underline} Species Report includes symbols which will cause issues later on.

[Procedure:]{.underline}

-   Check that Quotes = FALSE

```{r}
# Set parameters 
data <- SpeciesReport %>% 
  mutate(Quotes = pmap_lgl(as.list(SpeciesReport), 
    ~ any(str_detect(c(...), '["]')))) %>% 
  mutate(Quotes = ifelse(is.na(Quotes), FALSE, Quotes))
query <- "Species Report"
query_message <- "Quotes"
values_data <- data$Quotes
values_valid <- FALSE
values_check <- values_data == values_valid

# Identify errors
errors_SpeciesReport_Quotes <- qaqc(data, query, query_message, values_check)
```

-   Check that Commas = FALSE

```{r}
# Set parameters 
data <- SpeciesReport %>% 
  mutate(Commas = pmap_lgl(as.list(SpeciesReport), 
    ~ any(str_detect(c(...), '[,]')))) %>% 
  mutate(Commas = ifelse(is.na(Commas), FALSE, Commas))
query <- "Species Report"
query_message <- "Commas"
values_data <- data$Commas
values_valid <- FALSE
values_check <- values_data == values_valid

# Identify errors
errors_SpeciesReport_Commas <- qaqc(data, query, query_message, values_check)
```

-   Check that columns match expected

```{r}
# Set parameters 
data <- SpeciesReport
values_data <- names(data)
values_valid <- c("LocalSpecies_Symbol", "LocalSpecies_GUID", "LocalSpecies_Description", "LocalSpecies_CommonName", "LocalSpecies_LifeCycle", "LocalSpecies_UserAdded", "LocalSpecies_Nativity", "LocalSpecies_Invasive", "LocalSpecies_Cultural", "LocalSpecies_Concern", "LocalSpecies_Retired", "LocalSpecies_Comment", "LocalSpecies_UV1", "LocalSpecies_UV2", "LocalSpecies_UV3", "LocalSpecies_PreferedLifeForm", "MasterSpecies_ScientificName", "MasterSpecies_ITIS_TSN", "MasterSpecies_Genus", "MasterSpecies_Family", "MasterSpecies_NotBiolgoical", "ReportType")
MissingColumn <- setdiff(values_data, values_valid)
if(length(MissingColumn) == 0) {
  MissingColumn <- "none"
} else {
  MissingColumn <- paste((MissingColumn), collapse = ", ")
}

data$MissingColumn <- MissingColumn
query <- "Species Report"
query_message <- "Missing Columns"
values_data <- data$MissingColumn
values_valid <- "none"
values_check <- values_data == values_valid

# Identify errors
errors_SpeciesReport_Columns <- qaqc(data, query, query_message, values_check)
```

### Combine Sample Event Report Errors

```{r}
errors_SpeciesReport <- rbind(errors_SpeciesReport_Quotes, errors_SpeciesReport_Commas, errors_SpeciesReport_Columns)

remove(errors_SpeciesReport_Quotes, errors_SpeciesReport_Commas, errors_SpeciesReport_Columns)

if(nrow(errors_SpeciesReport) > 1) {
  errors_SpeciesReport <- errors_SpeciesReport %>%
    filter(Error != "No Error")
} else {
  errors_SpeciesReport <- errors_SpeciesReport}
```

# ALL ERRORS

```{r}
# Formatting

# Add blank rows between each tag number
errors_SpeciesReport_blanks <- errors_SpeciesReport[1, ]
for (i in 2:nrow(errors_SpeciesReport)) {
  if (errors_SpeciesReport[i, "LocalSpecies_Symbol"] != errors_SpeciesReport[i - 1, "LocalSpecies_Symbol"]) {
    errors_SpeciesReport_blanks <- rbind(errors_SpeciesReport_blanks, errors_blank, errors_SpeciesReport[i, ])
  } else {
    errors_SpeciesReport_blanks <- rbind(errors_SpeciesReport_blanks, errors_SpeciesReport[i, ])
  }
}

# Add conditional formating to ouput
errors_all <- condformat(errors_SpeciesReport_blanks[1:(nrow(errors_SpeciesReport_blanks)), 1:6]) %>%
  rule_fill_discrete(columns = 1:6,
                     expression = SavedQuery != "",
                     colours = c("TRUE" = "#C6E0B4"),
                     na.value = "#FFFFFF")
```

```{r}
# Table of results for quick check
kable(errors_all, "pipe")

# Save as CSV or XLSX
condformat2excel(errors_all, paste0(path_errors, paste0(target_park, "_errors_species.xlsx")), sheet_name = path_errors_name, overwrite_wb = TRUE)
```
